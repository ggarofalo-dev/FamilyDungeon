<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>D20 Dice Widget</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #111;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* ðŸ”¥ IL CONTENITORE governa tutto */
    #dice-container {
      width: 900px;               /* cambia qui se vuoi */
      max-width: 90vmin;
      aspect-ratio: 1 / 1;        /* sempre quadrato */
      background: #0f1116;
      border-radius: 12px;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>

<body>

<div id="dice-container">
  <canvas id="c"></canvas>
</div>

<script>
(() => {

  const container = document.getElementById("dice-container");
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  /* ---------------- Resize responsivo ---------------- */

  function resize() {
    const r = container.getBoundingClientRect();
    const dpr = Math.min(2, window.devicePixelRatio || 1);

    canvas.width  = Math.floor(r.width  * dpr);
    canvas.height = Math.floor(r.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  window.addEventListener("resize", resize);
  resize();

  /* ---------------- Math 3D ---------------- */

  const V3 = (x=0,y=0,z=0)=>({x,y,z});
  const add=(a,b)=>V3(a.x+b.x,a.y+b.y,a.z+b.z);
  const sub=(a,b)=>V3(a.x-b.x,a.y-b.y,a.z-b.z);
  const mul=(a,s)=>V3(a.x*s,a.y*s,a.z*s);
  const dot=(a,b)=>a.x*b.x+a.y*b.y+a.z*b.z;
  const cross=(a,b)=>V3(
    a.y*b.z - a.z*b.y,
    a.z*b.x - a.x*b.z,
    a.x*b.y - a.y*b.x
  );
  const len=(a)=>Math.hypot(a.x,a.y,a.z);
  const norm=(a)=>{ const l=len(a)||1; return V3(a.x/l,a.y/l,a.z/l); };

  /* Quaternion */
  const Q=(w=1,x=0,y=0,z=0)=>({w,x,y,z});
  const qMul=(a,b)=>Q(
    a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z,
    a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,
    a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,
    a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w
  );
  const qNorm=(q)=>{
    const l=Math.hypot(q.w,q.x,q.y,q.z)||1;
    return Q(q.w/l,q.x/l,q.y/l,q.z/l);
  };
  const qFromAxisAngle=(axis, ang)=>{
    const a = norm(axis);
    const s = Math.sin(ang/2);
    return qNorm(Q(Math.cos(ang/2), a.x*s, a.y*s, a.z*s));
  };
  const qRotate=(q,v)=>{
    const p=Q(0,v.x,v.y,v.z);
    const qi=Q(q.w,-q.x,-q.y,-q.z);
    const r=qMul(qMul(q,p),qi);
    return V3(r.x,r.y,r.z);
  };

  /* ---------------- D20 Geometry ---------------- */

  const phi = (1 + Math.sqrt(5)) / 2;

  const verts = [
    V3(-1,  phi, 0), V3( 1,  phi, 0), V3(-1, -phi, 0), V3( 1, -phi, 0),
    V3(0, -1,  phi), V3(0,  1,  phi), V3(0, -1, -phi), V3(0,  1, -phi),
    V3( phi, 0, -1), V3( phi, 0,  1), V3(-phi, 0, -1), V3(-phi, 0,  1),
  ].map(norm);

  const faces = [
    [0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],
    [1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],
    [3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],
    [4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1],
  ];

  const faceNumber = faces.map((_,i)=>i+1);
  const up = V3(0,0,1);
  const lightDir = norm(V3(-0.6,-0.3,1));

  /* ---------------- Dice State ---------------- */

  let rot = Q(1,0,0,0);
  let rolling = false;
  let startTime = 0;
  let finalFace = 1;
  const ROLL_MS = 3000;

  const getDieRadius = () =>
    Math.min(canvas.width, canvas.height) * 0.18;

  const diePos = () => V3(
    canvas.width / 2,
    canvas.height * 0.55,
    getDieRadius()
  );

  function pickTopFace(q){
    let best = {i:0,d:-1e9};
    for(let i=0;i<faces.length;i++){
      const f=faces[i];
      const va=qRotate(q,mul(verts[f[0]],getDieRadius()));
      const vb=qRotate(q,mul(verts[f[1]],getDieRadius()));
      const vc=qRotate(q,mul(verts[f[2]],getDieRadius()));
      const n=norm(cross(sub(vb,va),sub(vc,va)));
      const d=dot(n,up);
      if(d>best.d) best={i,d};
    }
    return faceNumber[best.i];
  }

  /* ---------------- Rendering ---------------- */

  function project(p){
    const cx=canvas.width/2;
    const cy=canvas.height/2;
    const camZ=720;
    const z=camZ+p.z;
    const s=camZ/z;
    return { x:(p.x-cx)*s+cx, y:(p.y-cy)*s+cy, s };
  }

  function draw(q, showNumber=true){
    const w=canvas.width, h=canvas.height;
    ctx.fillStyle="#ff1116";
    
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, "#f3e5c0");
    g.addColorStop(1, "#e6d3a3");
    ctx.fillStyle = g;
    
    
    ctx.fillRect(0,0,w,h);

    const pos=diePos();
    const r=getDieRadius();

    // shadow
    ctx.save();
    ctx.translate(pos.x,pos.y+r*0.95);
    ctx.fillStyle="rgba(0,0,0,0.45)";
    ctx.filter="blur(2px)";
    ctx.beginPath();
    ctx.ellipse(0,0,r*1.18,r*0.30,0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
    ctx.filter="none";

    const tv=verts.map(v=>add(pos,qRotate(q,mul(v,r))));
    const view=V3(0,0,1);

    const rf=faces.map((f,i)=>{
      const a=tv[f[0]],b=tv[f[1]],c=tv[f[2]];
      const n=norm(cross(sub(b,a),sub(c,a)));
      return {
        i,f,a,b,c,
        depth:(a.z+b.z+c.z)/3,
        facing:dot(n,view),
        lum:Math.max(0.08,dot(n,lightDir))
      };
    }).filter(x=>x.facing>-0.15).sort((a,b)=>a.depth-b.depth);

    for(const f of rf){
      const pa=project(f.a),pb=project(f.b),pc=project(f.c);
      const shade=Math.floor(235*f.lum);
      ctx.fillStyle=`rgb(${shade},${shade},${shade})`;
      ctx.strokeStyle="rgba(0,0,0,0.18)";
      ctx.beginPath();
      ctx.moveTo(pa.x,pa.y);
      ctx.lineTo(pb.x,pb.y);
      ctx.lineTo(pc.x,pc.y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }

    if(showNumber){
      const n=pickTopFace(q);
      const f=faces[n-1];
      const center=mul(add(add(tv[f[0]],tv[f[1]]),tv[f[2]]),1/3);
      const p=project(center);
      ctx.save();
      ctx.translate(p.x,p.y);
      ctx.font=`900 ${Math.max(26,36*p.s)}px system-ui`;
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.strokeStyle="rgba(255,255,255,0.55)";
      ctx.lineWidth=3;
      ctx.strokeText(n,0,0);
      ctx.fillStyle="rgba(10,12,18,0.92)";
      ctx.fillText(n,0,0);
      ctx.restore();
    }
  }

  /* ---------------- Animation ---------------- */

  const easeOut = t => 1 - Math.pow(1 - t, 3);

  function spinQuat(p){
    const e=easeOut(p);
    const a1=qFromAxisAngle(norm(V3(1,0.2,0.6)),10*Math.PI*(p+0.15*(1-e)));
    const a2=qFromAxisAngle(norm(V3(-0.3,1,0.2)),8*Math.PI*(p+0.1*(1-e)));
    const a3=qFromAxisAngle(norm(V3(0.1,-0.4,1)),6*Math.PI*(p+0.08*(1-e)));
    return qNorm(qMul(qMul(a1,a2),a3));
  }

  function snapToFace(q,target){
    let best=q,score=-1e9;
    for(let i=0;i<160;i++){
      const axis=norm(V3(Math.random()*2-1,Math.random()*2-1,Math.random()*2-1));
      const ang=Math.random()*0.8*Math.PI;
      const qq=qNorm(qMul(qFromAxisAngle(axis,ang),q));
      const f=faces[target-1];
      const va=qRotate(qq,mul(verts[f[0]],getDieRadius()));
      const vb=qRotate(qq,mul(verts[f[1]],getDieRadius()));
      const vc=qRotate(qq,mul(verts[f[2]],getDieRadius()));
      const n=norm(cross(sub(vb,va),sub(vc,va)));
      const d=dot(n,up);
      if(d>score){score=d;best=qq;}
    }
    return best;
  }

  function loop(t){
    if(rolling){
      const p=Math.min(1,(t-startTime)/ROLL_MS);
      const q=qNorm(qMul(spinQuat(p),rot));
      if(p<1){
        draw(q,p>0.8);
      }else{
        rot=snapToFace(q,finalFace);
        draw(rot,true);
        rolling=false;
        alert("Hai tirato: "+finalFace);
      }
    }else{
      draw(rot,true);
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function startRoll(){
    if(rolling) return;
    rolling=true;
    startTime=performance.now();
    finalFace=Math.floor(Math.random()*20)+1;
    rot=qFromAxisAngle(norm(V3(Math.random(),Math.random(),Math.random())),Math.random()*Math.PI*2);
  }

  canvas.addEventListener("click",startRoll);
  window.addEventListener("keydown",e=>{
    if(e.code==="Space"){e.preventDefault();startRoll();}
  });

})();
</script>

</body>
</html>
