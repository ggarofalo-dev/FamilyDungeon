<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>D20 - rotola sul posto (3s)</title>
  <style>
    html, body { margin:0; height:100%; background:#fff; overflow:hidden; }
    canvas { display:block; width:100%; height:100%; }
    .hud{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:#e9ecf1; font-size:14px; line-height:1.3;
      background: rgba(23,26,34,.72);
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
      padding:10px 12px;
      box-shadow: 0 18px 60px rgba(0,0,0,.35);
      user-select:none;
      max-width: min(560px, calc(100vw - 32px));
    }
    .muted{ color:#aab2c0; font-size:12px; }
    .pill{
      display:none; padding:2px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.06);
      margin-left:8px; font-size:12px; color:#d9ddea;
    }
    kbd{
      font: inherit;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(220,220,220,.25);
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hud">
    <div><b>D20</b> (rotola sul posto) <span class="pill" id="state">ready</span></div>
    <div class="muted">Click o <b>Spazio</b> = lancia · durata rotolamento: <b>3s</b></div>
    <div class="muted">Risultato: <b id="res">—</b></div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });
  const resEl = document.getElementById("res");
  const stateEl = document.getElementById("state");

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resize);
  resize();

  // --- 3D helpers
  const V3 = (x=0,y=0,z=0)=>({x,y,z});
  const add=(a,b)=>V3(a.x+b.x,a.y+b.y,a.z+b.z);
  const sub=(a,b)=>V3(a.x-b.x,a.y-b.y,a.z-b.z);
  const mul=(a,s)=>V3(a.x*s,a.y*s,a.z*s);
  const dot=(a,b)=>a.x*b.x+a.y*b.y+a.z*b.z;
  const cross=(a,b)=>V3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);
  const len=(a)=>Math.hypot(a.x,a.y,a.z);
  const norm=(a)=>{ const l=len(a)||1; return V3(a.x/l,a.y/l,a.z/l); };

  // Quaternion
  const Q=(w=1,x=0,y=0,z=0)=>({w,x,y,z});
  const qMul=(a,b)=>Q(
    a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z,
    a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,
    a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,
    a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w
  );
  const qNorm=(q)=>{ const l=Math.hypot(q.w,q.x,q.y,q.z)||1; return Q(q.w/l,q.x/l,q.y/l,q.z/l); };
  const qFromAxisAngle=(axis, ang)=>{
    const a = norm(axis);
    const s = Math.sin(ang/2);
    return qNorm(Q(Math.cos(ang/2), a.x*s, a.y*s, a.z*s));
  };
  const qRotate=(q,v)=>{
    const p=Q(0,v.x,v.y,v.z);
    const qi=Q(q.w, -q.x, -q.y, -q.z);
    const r=qMul(qMul(q,p), qi);
    return V3(r.x,r.y,r.z);
  };

  // Icosahedron (20 faces)
  const phi = (1 + Math.sqrt(5)) / 2;
  const verts = [
    V3(-1,  phi, 0), V3( 1,  phi, 0), V3(-1, -phi, 0), V3( 1, -phi, 0),
    V3(0, -1,  phi), V3(0,  1,  phi), V3(0, -1, -phi), V3(0,  1, -phi),
    V3( phi, 0, -1), V3( phi, 0,  1), V3(-phi, 0, -1), V3(-phi, 0,  1),
  ].map(v => norm(v));

  const faces = [
    [0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],
    [1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],
    [3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],
    [4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1],
  ];
  const faceNumber = faces.map((_,i)=>i+1);

  const up = V3(0,0,1);
  const lightDir = norm(V3(-0.6, -0.3, 1.0));

  const dieRadius = 95;
  const diePos = () => V3(window.innerWidth*0.5, window.innerHeight*0.55, dieRadius);

  let rot = Q(1,0,0,0);
  let rolling = false;

  // Rolling timeline
  const ROLL_MS = 3000;
  let startT = 0;

  // Choose a final face (so we stop “decisively”)
  let finalFace = 20;

  function pickTopFace(q){
    let best = {i:0, d:-1e9};
    for(let i=0;i<faces.length;i++){
      const [a,b,c] = faces[i];
      const va = qRotate(q, mul(verts[a], dieRadius));
      const vb = qRotate(q, mul(verts[b], dieRadius));
      const vc = qRotate(q, mul(verts[c], dieRadius));
      const n = norm(cross(sub(vb,va), sub(vc,va)));
      const d = dot(n, up);
      if(d > best.d) best = {i, d};
    }
    return faceNumber[best.i];
  }

  // Ease-out (fisico)
  const easeOutCubic = (t)=>1 - Math.pow(1-t, 3);

  // Project
  function project(p){
    const cx = window.innerWidth/2;
    const cy = window.innerHeight/2;
    const camZ = 720;
    const z = (camZ + p.z);
    const scale = camZ / z;
    return { x: (p.x - cx) * scale + cx, y: (p.y - cy) * scale + cy, s: scale };
  }

  function draw(q, showNumber=true){
    const w = window.innerWidth, h = window.innerHeight;

    ctx.fillStyle = "#f3e5c0"; // marrone pergamena / tavolo
    ctx.fillRect(0,0,w,h);

    //background: linear-gradient(180deg, #7a4a1f 0%, #5b3414 100%);
    
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, "#f3e5c0");
    g.addColorStop(1, "#e6d3a3");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    const pos = diePos();

    // shadow
    ctx.save();
    ctx.translate(pos.x, pos.y + dieRadius*0.95);
    ctx.fillStyle = "rgba(220,0,0,0.45)";
    ctx.filter = "blur(2px)";
    ctx.beginPath();
    ctx.ellipse(0,0, dieRadius*1.18, dieRadius*0.30, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
    ctx.filter = "none";

    const tv = verts.map(v => add(pos, qRotate(q, mul(v, dieRadius))));
    const view = V3(0,0,1);

    const renderFaces = faces.map((f, i) => {
      const a = tv[f[0]], b = tv[f[1]], c = tv[f[2]];
      const n = norm(cross(sub(b,a), sub(c,a)));
      const facing = dot(n, view);
      const depth = (a.z + b.z + c.z) / 3;
      const lum = Math.max(0.08, dot(n, lightDir));
      return { i, f, a, b, c, n, facing, depth, lum };
    })
    .filter(x => x.facing > -0.15)
    .sort((p,q) => p.depth - q.depth);

    for(const rf of renderFaces){
      const pa = project(rf.a), pb = project(rf.b), pc = project(rf.c);
      const base = 235;
      const shade = Math.floor(base * rf.lum);

      ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
      ctx.strokeStyle = "rgba(0,0,0,0.18)";
      ctx.lineWidth = 1;

      ctx.beginPath();
      ctx.moveTo(pa.x, pa.y);
      ctx.lineTo(pb.x, pb.y);
      ctx.lineTo(pc.x, pc.y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }

    if(showNumber){
      const topNum = pickTopFace(q);
      const faceIndex = topNum - 1;
      const f = faces[faceIndex];
      const a = tv[f[0]], b = tv[f[1]], c = tv[f[2]];
      const center = mul(add(add(a,b),c), 1/3);
      const p = project(center);

      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.font = `900 ${Math.max(26, 36 * p.s)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "rgba(10,12,18,0.92)";
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.lineWidth = 3;
      ctx.strokeText(String(topNum), 0, 0);
      ctx.fillText(String(topNum), 0, 0);
      ctx.restore();
    }
  }

  function startRoll(){
    if(rolling) return;
    rolling = true;
    stateEl.textContent = "rolling";
    resEl.textContent = "—";
    startT = performance.now();

    // scegli risultato finale (uniforme)
    finalFace = Math.floor(Math.random()*20) + 1;

    // base rot random
    rot = qNorm(qFromAxisAngle(norm(V3(Math.random(),Math.random(),Math.random())), Math.random()*Math.PI*2));
  }

  // Make a "spin" quaternion at time t using multiple axes (feels random but stable)
  function spinQuat(progress){
    // progress 0..1
    // early: high angular speed, late: slow
    const e = easeOutCubic(progress);
    const speed = (1 - e); // 1..0

    // total rotation amounts (radians)
    const ax1 = norm(V3(1, 0.2, 0.6));
    const ax2 = norm(V3(-0.3, 1, 0.15));
    const ax3 = norm(V3(0.1, -0.4, 1));

    const a1 = (10.0 * Math.PI) * (progress + 0.15*speed);
    const a2 = (8.0  * Math.PI) * (progress + 0.10*speed);
    const a3 = (6.0  * Math.PI) * (progress + 0.08*speed);

    const q1 = qFromAxisAngle(ax1, a1);
    const q2 = qFromAxisAngle(ax2, a2);
    const q3 = qFromAxisAngle(ax3, a3);

    return qNorm(qMul(qMul(q1,q2), q3));
  }

  // After rolling, we "snap" to a rotation where top face == finalFace
  // We'll find a nearby rotation by random search around current rotation.
  function snapToFace(currentQ, targetFace){
    // Find a quaternion close to currentQ that puts targetFace on top.
    // We do a small stochastic search (fast enough for 20 faces).
    let bestQ = currentQ;
    let bestScore = -1e9;

    for(let i=0;i<180;i++){
      const axis = norm(V3(Math.random()*2-1, Math.random()*2-1, Math.random()*2-1));
      const ang  = (Math.random()*0.9) * Math.PI; // small-ish
      const qj = qFromAxisAngle(axis, ang);
      const q = qNorm(qMul(qj, currentQ));

      // score: dot(topNormal, up) for desired face
      const f = faces[targetFace-1];
      const va = qRotate(q, mul(verts[f[0]], dieRadius));
      const vb = qRotate(q, mul(verts[f[1]], dieRadius));
      const vc = qRotate(q, mul(verts[f[2]], dieRadius));
      const n = norm(cross(sub(vb,va), sub(vc,va)));
      const score = dot(n, up);

      if(score > bestScore){
        bestScore = score;
        bestQ = q;
      }
      if(bestScore > 0.999) break;
    }
    return bestQ;
  }

  // animation loop
  function loop(t){
    if(rolling){
      const elapsed = t - startT;
      const p = Math.min(1, elapsed / ROLL_MS);

      // during roll: don't show stable number (optional). io lo mostro solo negli ultimi 20%.
      const showNum = p > 0.80;

      // compose: base rot * spin
      const spin = spinQuat(p);
      const q = qNorm(qMul(spin, rot));

      if(p < 1){
        draw(q, showNum);
      } else {
        // snap to target face and stop
        const snapped = snapToFace(q, finalFace);
        draw(snapped, true);

        rolling = false;
        stateEl.textContent = "settled";
        resEl.textContent = finalFace;
        // keep final rotation
        rot = snapped;
      }
    } else {
      // idle draw
      draw(rot, true);
    }

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // controls
  canvas.addEventListener("click", startRoll);
  window.addEventListener("keydown", (e)=>{
    if(e.code==="Space"){
      e.preventDefault();
      startRoll();
    }
  });
})();
</script>
</body>
</html>
